***You***: Auth.net error -- 

Transaction Type: authCaptureTransaction
paymentToken: 1234567890ABCDEF1111AAAA2222BBBB3333CCCC4444DDDD5555EEEE6666FFFF7777888899990000

Amount: 1000.5
Invoice Number: ORD-12349
Description: Purchase of goods and services
Payment Data Descriptor: COMMON.ACCEPT.INAPP.PAYMENT
Payment Token: 1234****0000
Merchant Order ID: ORD-12349
Order ID: 2df37065-e0e3-43bc-a97e-73c97777784e

Result Code: ERROR
Messages:
  - Code: E00001, Text: An error occurred during processing. Please try again.
Transaction Response Code: null
Transaction ID: null
Auth Code: null
AVS Response: null
CVV Response: null
***ChatGPT***: This is a **generic Authorize.Net gateway failure**, but given the exact fields you shared, there are **very specific red flags**. Letâ€™s break it down cleanly and pragmatically.

 


## What the error means (E00001)

**E00001 â€“ â€œAn error occurred during processingâ€** is a **catch-all gateway error** from **Authorize.Net**.
It usually means **the request was rejected before a transaction was even created**, which is why **all transaction response fields are null**:

  - 
âŒ Transaction ID â†’ not created

  - 
âŒ Auth Code â†’ not generated

  - 
âŒ AVS / CVV â†’ not evaluated

So this is **not a decline** â€” itâ€™s a **request validation or token failure**.

 


## The primary issue (this is the real bug)


### âŒ `COMMON.ACCEPT.INAPP.PAYMENT` is being used incorrectly

Youâ€™re sending:

ğŸ‘‰ **This descriptor is ONLY valid for mobile SDKâ€“generated opaque data**, **not web tokens**, and **not manually copied values**.

### What Authorize.Net expects

For `COMMON.ACCEPT.INAPP.PAYMENT`:
RequirementStatusToken generated by **Accept Mobile SDK (iOS/Android)**âŒToken generated **within last 15 minutes**âŒToken bound to **sandbox vs prod merchant**âŒ unknownToken used **exactly once**âŒ unknown
If **any** of these fail â†’ **E00001**

 


## Secondary issue (will also break it)


### âŒ Amount format: `1000.5`

Authorize.Net requires **2 decimal places**.
âœ… Correct:

âŒ Incorrect:

This alone can cause **E00001** in strict validation paths.

 


## Another likely issue


### âŒ Token masking mismatch

You sent:

Authorize.Net does **not** accept:

  - 
masked tokens

  - 
transformed tokens

  - 
logged-and-reused tokens

You must send the **raw opaqueData value**, untouched, directly from the client SDK.

 


## What is definitely NOT the problem

âœ” Invoice number format â†’ OK

âœ” Order ID UUID â†’ OK

âœ” authCaptureTransaction â†’ OK

âœ” Amount size â†’ OK (value-wise)

âœ” Description â†’ OK

 


## Correct way to do this (reference implementation)


### Mobile (Accept SDK)

Client generates:

Backend sends **exactly that** to Authorize.Net **once**, within **15 minutes**.

 


### Web (Accept.js) â€” different descriptor

If this is **web-based**, you must use:

And the token must come from **Accept.js**, not mobile SDKs.

 


## Immediate fixes checklist (do these now)


  1. 
âœ… Ensure token is generated by the **correct SDK**

    - 
Mobile â†’ Accept SDK

    - 
Web â†’ Accept.js


  2. 
âœ… Fix amount â†’ `1000.50`

  3. 
âœ… Do NOT reuse tokens

  4. 
âœ… Do NOT mask or modify the token

  5. 
âœ… Sandbox token â†’ sandbox merchant

  6. 
âœ… Production token â†’ production merchant


 


## Debug tip (very important)

Enable **transaction logging** in Authorize.Net Sandbox:

This will show the **real rejection reason** instead of E00001.

 


## If you want next steps

I can:

  - 
Validate your **exact API payload**

  - 
Tell you **which SDK you should be using**

  - 
Provide **Spring Bootâ€“ready request code**

  - 
Help you design a **token lifecycle contract** for your orchestration service

Just tell me:

ğŸ‘‰ **Is this token coming from mobile or web?**
***You***: copied the token from authorize documentation example.
***ChatGPT***: That explains **everything**. ğŸ‘

This error is **100% expected** in that case.

 


## Why this failed (no ambiguity here)

You copied this from **Authorize.Net documentation**:

Those values are **NOT real payment tokens**.
ğŸ‘‰ **Authorize.Net documentation tokens are placeholders only**

They are **syntactically valid** but **cryptographically invalid**.
So when the gateway tries to decrypt/validate them â†’

**hard reject â†’ E00001 â†’ no transaction created**
Thatâ€™s exactly what youâ€™re seeing.

 


## Critical rule (non-negotiable)


**Authorize.Net opaqueData tokens can ONLY be generated by their client SDKs.**

You **cannot**:

  - 
generate them server-side

  - 
reuse them

  - 
copy them from docs

  - 
hardcode them for testing

  - 
mock them (unless you mock the gateway entirely)


 


## Correct way to test (Sandbox)


### Option 1 â€” Web (Accept.js)


**Flow**

  1. 
Browser loads Accept.js

  2. 
User enters card details

  3. 
Accept.js returns:


  4. 
Send that to your backend

  5. 
Backend calls Authorize.Net

âœ” Works in **sandbox**

âœ” No PCI scope

 


### Option 2 â€” Mobile (Accept SDK)


**Flow**

  1. 
iOS / Android Accept SDK

  2. 
SDK generates:


  3. 
Token valid **15 minutes**

  4. 
Use once

âœ” Works in **sandbox**

âœ” Token is device-bound

 


## If you want backend-only testing (important for you)

Since youâ€™re building a **payment orchestration service**, this is the **right approach**:

### Mock Authorize.Net at the gateway layer

**DO NOT try to fake opaqueData.**
Instead:

  - 
Mock the **Authorize.Net SDK client**

  - 
Return a **synthetic success response**

  - 
Validate:

    - 
idempotency

    - 
state transitions

    - 
retries

    - 
webhooks


This aligns perfectly with your earlier architecture decisions.

 


## Quick sanity checklist

ScenarioWorks?Hardcoded tokenâŒCopied doc tokenâŒExpired tokenâŒWrong descriptorâŒSDK-generated sandbox tokenâœ…Mocked gatewayâœ…

 


## What I recommend you do next

Given your system design:

  1. 
**Short term**

    - 
Mock Authorize.Net responses

    - 
Finish orchestration logic


  2. 
**Integration phase**

    - 
Add a minimal Accept.js page

    - 
Generate real sandbox tokens

    - 
Wire end-to-end



 

If you want, I can:

  - 
Give you a **minimal Accept.js HTML page** for sandbox

  - 
Show **Spring Boot SDK code** using opaqueData

  - 
Help you design a **clean gateway abstraction** so this never bites you again

Just tell me which one you want.
***You***: Give you a minimal Accept.js HTML page for sandbox
***ChatGPT***: Perfect. Below is a **minimal, copy-paste Accept.js sandbox HTML page** that will generate a **real opaqueData token** you can send to your backend.
This is **the smallest possible working setup** â€” no styling, no frameworks, no PCI scope creep.

 


## What this page does


  - 
Uses **Accept.js (sandbox)**

  - 
Collects **card number, expiry, CVV**

  - 
Generates:

    - 
`dataDescriptor: COMMON.ACCEPT.PAYMENT`

    - 
`dataValue: <opaque token>`


  - 
Prints the token so you can copy or POST it to your backend


 


## Sandbox prerequisites (must do)

From **Authorize.Net Sandbox**:

  1. 
Login to sandbox

  2. 
**Account â†’ Settings â†’ Security Settings**

  3. 
Enable **Accept.js**

  4. 
Note:

    - 
**API Login ID**

    - 
**Client Key** (NOT Transaction Key)



 


## Minimal Accept.js sandbox HTML (copy-paste)



 


## Expected success output


ğŸ‘‰ **Send this EXACT pair to your backend**

ğŸ‘‰ **Do not modify, mask, log, or reuse**

 


## Backend usage reminder

When calling Authorize.Net:

  - 
Use:


  - 
Amount must be:


  - 
Token is **single-use**

  - 
Token expires (~15 min)


 


## Common sandbox test cards

CardResult4111111111111111Visa â€“ success4007000000027Visa â€“ decline5424000000000015Mastercard â€“ success

 


## Next steps (recommended for your system)

Given your orchestration service:

  1. 
Wrap this page as a **temporary internal test UI**

  2. 
Wire token â†’ backend â†’ mocked gateway

  3. 
Later swap mock â†’ real Authorize.Net SDK

If you want, I can now:

  - 
Add **POST to your Spring Boot API**

  - 
Give **Authorize.Net SDK Java code**

  - 
Show **idempotent retry-safe flow**

Just say which one.
***You***: {
  "messages": {
    "resultCode": "Error",
    "message": [
      {
        "code": "E_WC_02",
        "text": "A HTTPS connection is required."
      }
    ]
  }
}

https is required. can this be skipped ?
***ChatGPT***: Short answer: **âŒ No, it cannot be skipped.**

Long answer below, with **practical ways to unblock you immediately**.

 


## Why HTTPS is mandatory (hard rule)

**Authorize.Net Accept.js** enforces HTTPS **in the browser itself**.
This is **not a merchant setting** and **not configurable**.
**Why:**

  - 
Card data touches the DOM

  - 
Browsers forbid secure JS SDKs on HTTP

  - 
Prevents MITM + token exfiltration

So this error:

means **Accept.js refused to run** before tokenization.

 


## What you CAN do (fastest â†’ cleanest)


### âœ… Option 1 (Fastest): Use localhost HTTPS (recommended)

Modern browsers treat `https://localhost` as secure.

#### One-liner (mkcert â€“ easiest)


Then serve with HTTPS:

Use a simple HTTPS server (Node / Python / Caddy / Nginx).
Access:

âœ” Works immediately

âœ” No public exposure

âœ” No cert warnings

 


### âœ… Option 2: Use a tunnel (ngrok / cloudflared)


Youâ€™ll get:

Serve your HTML on port 8080.
âœ” Zero config

âœ” Real HTTPS

âš  External dependency

 


### âœ… Option 3: Serve via Spring Boot HTTPS (best parity)

Since you already have Spring Boot:

  1. 
Enable SSL in `application.yml`

  2. 
Serve this HTML as a static resource

  3. 
Hit:


âœ” Matches production flow

âœ” Good long-term approach

 


## What you CANNOT do

AttemptResultHTTP + Accept.jsâŒDisable HTTPS checkâŒReverse proxy without TLSâŒBackend-only token generationâŒCopied tokenâŒ

 


## Minimal HTTPS setup (2 minutes)


### Using Node (quickest)


Then:


 


## Why sandbox is strict (important insight)

Sandbox enforces HTTPS **because prod does**.
If they allowed HTTP:

  - 
Developers would ship insecure flows

  - 
Tokens would leak

  - 
PCI violations explode

So sandbox pain = production safety.

 


## Recommendation for your architecture

Given youâ€™re building a **payment orchestration service**:
âœ” Keep Accept.js **outside** backend repo

âœ” Use it only to generate tokens

âœ” Treat opaqueData as **write-only secrets**

âœ” Mock gateway for unit tests
This keeps your core clean and testable.

 


## Bottom line


**HTTPS is mandatory. Period.**

But you can unblock yourself **today** with:

  - 
`mkcert + localhost`

  - 
or `ngrok`

If you want, I can:

  - 
Give you a **copy-paste HTTPS server**

  - 
Help you wire **Accept.js â†’ Spring Boot POST**

  - 
Show **production-safe Accept.js deployment**

Just tell me which one.
***You***: method 1 , 
.../payment_gateway_integration/frontend > python3 -m http.server --bind localhost 8443
Serving HTTP on ::1 port 8443 (http://[::1]:8443/) ...
::1 - - [03/Jan/2026 11:41:47] code 400, message Bad request version ('NOcÂ«\\x07BÃ¦G"Â´ÃK\\x94z-\\x0eIÃ²\\x00"\\x13\\x01\\x13\\x03\\x13\\x02Ã€+Ã€/ÃŒÂ©ÃŒÂ¨Ã€,Ã€0Ã€')
::1 - - [03/Jan/2026 11:41:47] "\x16\x03\x01\x07a\x01\x00\x07]\x03\x03UNJL\x96ÃŠ;\x09\x8e\x87Â±\x1c\x94p1\x01\x14H\\;Â¤aÃ›\x92*mIÃ¦Â³Ã¡;Â© Â¯Ã½G\x93)Ã³.7Ã…LÃ½\x19Â­\x1dNOcÂ«\x07BÃ¦G"Â´ÃK\x94z-\x0eIÃ²\x00"\x13\x01\x13\x03\x13\x02Ã€+Ã€/ÃŒÂ©ÃŒÂ¨Ã€,Ã€0Ã€" 400 -
::1 - - [03/Jan/2026 11:41:47] code 400, message Bad request version ('\\x87\\x1b4\\x19\\x13Â±{Â«JÃ„ugÃ¢\\x82\\x8f\\x9a&ZEddTm]:2auAeÃœ8\\x00"\\x13\\x01\\x13\\x03\\x13\\x02Ã€+Ã€/ÃŒÂ©ÃŒÂ¨Ã€,Ã€0Ã€')
::1 - - [03/Jan/2026 11:41:47] "\x16\x03\x01\x02\x90\x01\x00\x02\x8c\x03\x03-\x94\x19Ã¥Ãº\x9eÃŠ0\x9fzÂ±Ã²{Â \x0d\x0b\x8c4Ã«\x1f\x00Ã°\x19Ã°ÃÃ¸/\x14ÃŒ$w\\ \x87\x1b4\x19\x13Â±{Â«JÃ„ugÃ¢\x82\x8f\x9a&ZEddTm]:2auAeÃœ8\x00"\x13\x01\x13\x03\x13\x02Ã€+Ã€/ÃŒÂ©ÃŒÂ¨Ã€,Ã€0Ã€" 400 -
***ChatGPT***: Youâ€™re **very close**, but this log tells us exactly what went wrong.

 


## What happened (decoded)

You did this:

Then opened:


### âŒ Problem

`python3 -m http.server` is **HTTP-only**.
When the browser tries **HTTPS**, it sends a **TLS handshake**.

Your server expects plain HTTP â†’ it sees encrypted bytes â†’ logs garbage like:

This is **100% expected behavior**.

**Port â‰  HTTPS**

HTTPS requires **TLS**, not just a different port number.


 


## Why Accept.js still complains

Accept.js checks:

  - 
`window.location.protocol === "https:"` âœ…

  - 
AND **real TLS connection** âŒ

Since no TLS is happening â†’ `E_WC_02`

 


## Correct fix (Method 1 done properly)

You need **HTTPS + certificate**.

### âœ… Easiest & cleanest: `mkcert` (recommended)


#### 1ï¸âƒ£ Install mkcert



#### 2ï¸âƒ£ Create a local trusted CA



#### 3ï¸âƒ£ Generate certs for localhost


This creates:


 


## Start a REAL HTTPS server (Python)

Create `https_server.py`:

Run it:

Now open:

âœ” Browser shows **secure**

âœ” No cert warnings

âœ” Accept.js works

 


## Why this is the correct approach


  - 
Real TLS handshake âœ”

  - 
Trusted cert âœ”

  - 
Matches production behavior âœ”

  - 
No hacks âœ”

This is **exactly** what **Authorize.Net Accept.js expects.

 


## What NOT to do (important)

AttemptOutcomeUse HTTP server on HTTPS URLâŒDisable browser securityâŒProxy HTTPS â†’ HTTPâŒSelf-signed cert without trustâš ï¸ flakyTry to bypass Accept.jsâŒ

 


## Quick verification checklist

Open DevTools â†’ Console:

Must return:

Then submit the form â†’ you should get:


 


## Why this matters for your system design

Youâ€™re building a **payment orchestration service** â€” this is good discipline:

  - 
TLS enforced early

  - 
Tokenization isolated

  - 
Backend never touches PAN data

  - 
PCI scope minimized

Exactly the right direction.

 


## Next logical step (recommended)

Once this works:

  1. 
POST opaqueData â†’ Spring Boot endpoint

  2. 
Call Authorize.Net sandbox

  3. 
Then **remove this page from prod builds**

If you want, I can:

  - 
Wire this page to your **existing backend API**

  - 
Give you **Authorize.Net Java SDK code**

  - 
Help you **mock gateway cleanly**

Just say the word.
***You***: === Authorize.Net Request (PURCHASE) ===
Transaction Type: authCaptureTransaction
Amount: 100.5
Invoice Number: SUB-12345-cycle-1
Description: Monthly premium subscription - Billing Cycle 1
Payment Data Descriptor: COMMON.ACCEPT.INAPP.PAYMENT
Payment Token: eyJj****MSJ9
Merchant Order ID: SUB-12345-cycle-1
Order ID: 86a0b681-e239-45fc-ac84-a7a7fbcfac3c
===========================================
2026-01-04 17:08:43.976 [pool-7-thread-1] WARN  [] [] net.authorize.util.HttpClient - Defaulting to non-proxy environment
2026-01-04 17:08:47.478 [http-nio-8080-exec-2] DEBUG [2654371d-7718-408e-a285-0254e9681560] [purchase] c.p.gateway.impl.AuthorizeNetGateway - Authorize.Net Response Body:

=== Authorize.Net Response (PURCHASE) ===
Result Code: ERROR
Messages:
  - Code: E00114, Text: Invalid OTS Token.
Transaction Response Code: null
Transaction ID: null
Auth Code: null
AVS Response: null
CVV Response: null
===========================================
***ChatGPT***: This error is **very precise** now. Youâ€™re past HTTPS and tokenization â€” this is an **opaque token mismatch**.

 


## What `E00114 â€“ Invalid OTS Token` really means

From **Authorize.Net**:

**OTS = One-Time-Use (opaque) Token**

This error means the token **cannot be validated for this request**.

Importantly:

  - 
âŒ This is **not** a network error

  - 
âŒ This is **not** a generic gateway error

  - 
âŒ This is **not** a decline

Authorize.Net **recognized** the token format, but **rejected its context**.

 


## You have **two concrete problems** in your request


### âŒ 1. Wrong descriptor for Accept.js

Your log says:

But earlier you generated the token using **Accept.js (web)**.

#### Correct mapping (strict rule)

Token sourceRequired descriptor**Accept.js (Web)**`COMMON.ACCEPT.PAYMENT`**Accept Mobile SDK**`COMMON.ACCEPT.INAPP.PAYMENT`
â¡ï¸ If these donâ€™t match **exactly** â†’ `E00114`
âœ… **Fix**

Change descriptor to:


 


### âŒ 2. Amount format is still invalid

Youâ€™re sending:

Authorize.Net requires **two decimals always**.
âœ… Correct:

This alone can invalidate token processing in the transaction pipeline.

 


## Very likely (third common cause)


### âŒ Token reuse or token delay

Opaque tokens are:

  - 
**Single-use**

  - 
**Short-lived (~15 minutes)**

If:

  - 
You logged the token and replayed it

  - 
You retried the same request

  - 
You used async processing with delay

â†’ token is invalid â†’ `E00114`

 


## Final fix checklist (do all)


### Backend


  - 
 Change descriptor â†’ `COMMON.ACCEPT.PAYMENT`

  - 
 Format amount â†’ `100.50`

  - 
 Ensure token used **exactly once**

  - 
 Ensure token freshness (<15 min)

  - 
 Sandbox token â†’ sandbox credentials only


### Frontend


  - 
 Accept.js only

  - 
 Do **not** mask token (`eyJj****MSJ9` is logging only â€” never send masked)

  - 
 POST token immediately


 


## Sanity check (this must match)

What Accept.js returns:

What your backend sends to Authorize.Net:

**No transformation. No masking. No reuse.**

 


## Why this is actually good news

Youâ€™ve confirmed:

  - 
HTTPS âœ”

  - 
Accept.js âœ”

  - 
Token generation âœ”

  - 
Gateway connectivity âœ”

This is now **pure contract correctness**, not infra.

 


## If you want next help

I can:

  - 
Review your **exact Java SDK request object**

  - 
Spot descriptor/amount bugs instantly

  - 
Give you a **â€œtoken-safeâ€ retry & idempotency pattern** for subscriptions

Just paste the request-building code.
***You***: Code: E00121, Text: No default payment/shipping profile found
***ChatGPT***: This one is **very clear and very fixable**.

Youâ€™ve now crossed into **CIM / profile-related behavior** in **Authorize.Net**.

 


## What `E00121` actually means


**E00121 â€“ No default payment/shipping profile found**

Authorize.Net is telling you:

â€œYou asked me to charge a **customer profile**, but that profile does not have a **default payment profile** (or shipping profile).â€

This error **only occurs** when **Customer Information Manager (CIM)** logic is involved.

 


## Why youâ€™re seeing this (root cause)

You are mixing **two mutually exclusive flows**:

### Flow A â€” Opaque token (Accept.js / Accept SDK)


  - 
Uses `opaqueData`

  - 
**Does NOT require** customer profiles

  - 
No default payment profile needed


### Flow B â€” Customer Profile (CIM)


  - 
Uses `customerProfileId`

  - 
Uses `customerPaymentProfileId`

  - 
**Requires** a default payment profile

ğŸ‘‰ Your request is being interpreted as **Flow B**, but you did not configure CIM correctly.

 


## The usual mistake that triggers E00121

One of these is present in your request (even implicitly):

  - 
`customerProfileId`

  - 
`profile` object

  - 
`createProfile = true`

  - 
Subscription API without payment profile

  - 
ARB (recurring billing) without a default payment profile

As soon as **any profile reference exists**, Authorize.Net expects:

If missing â†’ **E00121**

 


## How to fix it (choose ONE path)


 


## âœ… Option 1 â€” One-time purchase (NO profiles)

If this is a **normal purchase / authCapture**:

### What your request must contain


  - 
`opaqueData` only

  - 
âŒ NO customer profile fields


ğŸš« Do **NOT** include:

  - 
customerProfileId

  - 
profile block

  - 
subscription references

âœ” No default profile needed

âœ” No E00121

 


## âœ… Option 2 â€” Subscription / saved card (CIM REQUIRED)

If this is a **subscription / recurring payment**, then:

### Required steps (cannot skip)


  1. 
**Create Customer Profile**

  2. 
**Create Payment Profile**

  3. 
**Mark it as default**

  4. 
**Use that profile in transactions**


#### Create customer profile (once)



#### Create payment profile



#### Set default payment profile


Only after this can you:

  - 
Create subscriptions

  - 
Charge using profile IDs


 


## Important rule for subscriptions (critical)


**ARB subscriptions CANNOT use opaqueData directly**

They **must** use:

  - 
customerProfileId

  - 
customerPaymentProfileId

If you tried to create a subscription using an opaque token â†’

Authorize.Net internally switches to CIM â†’ E00121.

 


## Decision table (very important)

Use caseUse opaqueDataUse CIMOne-time paymentâœ…âŒImmediate chargeâœ…âŒSave cardâŒâœ…SubscriptionâŒâœ…Retry future chargesâŒâœ…

 


## What I strongly suspect in your case

Youâ€™re doing **subscription billing** (`SUB-12345-cycle-1`) and likely using:

  - 
ARB APIs

  - 
or a â€œsave cardâ€ flag

  - 
or profile creation implicitly

â€¦but **without creating a default payment profile first**.
Hence:


 


## What to do next (fastest path)

Tell me **which one this is**:
1ï¸âƒ£ One-time purchase â†’ Iâ€™ll show the **exact minimal request**

2ï¸âƒ£ Subscription â†’ Iâ€™ll give you the **correct CIM + ARB sequence**

3ï¸âƒ£ Hybrid (first charge + save card) â†’ Iâ€™ll give a **safe 2-step flow**
Paste your **request-building code** and Iâ€™ll spot the exact field causing this in one pass.
***You***: createCustomerPaymentProfileRequest 
is it per customer ? what information does it hold
***ChatGPT***: Yes â€” **createCustomerPaymentProfileRequest is per customer**, and it represents **one saved payment method** for that customer in **Authorize.Net CIM (Customer Information Manager)**.
Below is the **exact mental model**, what it stores, and how itâ€™s used.

 


## Big picture (3-layer model)

Authorize.Net CIM has **three distinct objects**:


### 1ï¸âƒ£ Customer Profile


  - 
One per logical customer

  - 
Identified by `customerProfileId`


### 2ï¸âƒ£ Customer **Payment** Profile (your question)


  - 
**Many per customer**

  - 
Each represents **one payment method**

  - 
Identified by `customerPaymentProfileId`


### 3ï¸âƒ£ Customer Shipping Profile


  - 
Optional

  - 
Used only if shipping is relevant


 


## Soâ€¦ is `createCustomerPaymentProfileRequest` per customer?

âœ… **Yes**
It always attaches to **one existing customer profile**:

You can create:

  - 
1 card

  - 
5 cards

  - 
10 cards

all under the **same customer**


 


## What information a Payment Profile holds

A **payment profile stores tokenized payment data**, **not raw card details**.

### Core fields it contains


### ğŸ” Payment data (one of these)


  - 
Credit card (most common)

  - 
Bank account (ACH)

For a **credit card**, it stores:

  - 
Card brand (Visa, MC, etc.)

  - 
Last 4 digits

  - 
Expiry month/year

  - 
Internal secure token (vaulted by Authorize.Net)

â— **Full PAN is never retrievable**

 


### ğŸ‘¤ Billing address (optional but recommended)


  - 
First name

  - 
Last name

  - 
Address

  - 
ZIP (important for AVS)

  - 
Country

Used for:

  - 
Fraud checks

  - 
AVS

  - 
Compliance


 


### â­ Default flag (very important)

Each customer can have:

  - 
**One default payment profile**

Authorize.Net will:

  - 
Use it automatically for subscriptions

  - 
Use it if payment profile ID is omitted (where allowed)

If no default exists â†’ **E00121**

 


## What it does NOT store

âŒ CVV (never stored)

âŒ Raw card number

âŒ Expired tokens

âŒ Accept.js opaque tokens
Opaque tokens are **input only**, used once to create this profile.

 


## How it fits in your flow (important)


### Correct lifecycle


#### Step 1 â€” Frontend (Accept.js)

Generates:


#### Step 2 â€” Backend

Uses that opaque token to call:

Authorize.Net:

  - 
Vaults the card

  - 
Creates `customerPaymentProfileId`


#### Step 3 â€” Future usage

You charge using:

No Accept.js needed again.

 


## Typical use cases

Use casePayment Profile neededOne-time purchaseâŒSave cardâœ…Subscription (ARB)âœ…Recurring billingâœ…Retry failed paymentsâœ…Customer walletâœ…

 


## Why your earlier error happened (connecting the dots)

You saw:

That means:

  - 
A **customer profile existed**

  - 
But **no default payment profile** was set

Subscriptions **require**:


 


## Practical recommendations (for your system)


### For your payment orchestration design


  - 
Treat **Payment Profile = durable funding source**

  - 
Treat **opaqueData = transient input**

  - 
Never retry with opaqueData

  - 
Retry with **payment profile IDs**


### Naming tip

Internally, think of it as:

not â€œcardâ€.

 


## If you want next

I can:

  - 
Show the **exact Java request object**

  - 
Show **create profile + payment profile + subscription** end-to-end

  - 
Help you design **idempotent profile creation**

Just tell me which one.
***You***: I do have a payment method is it the same ?
***ChatGPT***: Short answer: **Yes â€” that is a Customer Payment Profile.**

But thereâ€™s **one critical catch** that explains your error.

 


## What the screenshot confirms âœ…

From the **Authorize.Net** UI:

  - 
**Customer Profile ID** exists

â†’ `52522629`

  - 
**Payment Profile ID** exists

â†’ `537402523`

  - 
Card is vaulted (Visa ****1111, exp 12/2027)

So this **is the same thing** as what `createCustomerPaymentProfileRequest` creates.

 


## Why youâ€™re still getting `E00121`


**Having a payment method â‰  having a DEFAULT payment profile**


### `E00121` is thrown when:


  - 
A **customer profile exists**

  - 
A **payment profile exists**

  - 
âŒ **No default payment profile is set**

The Authorize.Net UI will happily show cards **without marking any as default**.
Subscriptions (ARB) and some profile-based charges **require** a default.

 


## How to verify this in the UI (important)

In your screenshot:

  - 
There is **no â€œDefaultâ€ indicator**

  - 
The â€œâ€¦â€ menu does **not** show â€œSet as defaultâ€ selected

That means:

â¡ï¸ Result: **E00121**

 


## How to fix it (2 ways)


### âœ… Option 1 â€” Set default in the Dashboard (fastest)


  1. 
Go to **Payment methods**

  2. 
Click **â‹¯** next to the card

  3. 
Choose **Set as default payment method**

  4. 
Save

Thatâ€™s it.

Your existing profile will now work for:

  - 
Subscriptions

  - 
Profile-based charges


 


### âœ… Option 2 â€” Set default via API (recommended for prod)

You must explicitly update the customer profile.
Conceptually:

Once this is set:

  - 
You **do not** need to pass paymentProfileId every time

  - 
ARB subscriptions will succeed


 


## Very important usage rule (this trips people up)


### Charging a profile is **not** the same as charging a token


#### âŒ Wrong (mixing models)


  - 
`opaqueData`

  - 

    - 
`customerProfileId`



#### âœ… Correct (profile-based)


  - 
`customerProfileId`

  - 
`customerPaymentProfileId` (or default)

Once a payment profile exists:

**Do NOT use Accept.js for future charges**


 


## Mental model (keep this)



 


## Why your earlier flow failed (connecting all dots)


  1. 
You successfully created a payment profile âœ”

  2. 
You moved to subscription / profile-based charge âœ”

  3. 
No default payment profile existed âŒ

  4. 
Authorize.Net raised `E00121`

This is **correct behavior**, not a bug.

 


## Final checklist for you


  - 
 Customer profile exists

  - 
 Payment profile exists

  - 
 **Default payment profile set**

  - 
 Use **profile IDs**, not opaque tokens

  - 
 Amount formatted with 2 decimals


 

If you want, next I can:

  - 
Show the **exact Java SDK call** to set default

  - 
Validate your **subscription creation request**

  - 
Help you design a **clean â€œsave card + subscribeâ€ flow**

Just tell me which one.
***You***: how to set it as default from UI
***ChatGPT***: Hereâ€™s how to **set a payment method as the DEFAULT from the Authorize.Net UI**. This is quick and doesnâ€™t require any API calls.
Authorize.Net

 


## Step-by-step (UI)

4

  1. 
**Open the Customer Profile**

    - 
Go to **Customer Profiles**

    - 
Click the customer (the page youâ€™re already on)


  2. 
**Go to â€œPayment methodsâ€**

    - 
Youâ€™ll see the list of cards (like your Visa ****1111)


  3. 
**Open the actions menu**

    - 
Click the **â‹¯ (three dots)** next to the card you want as default


  4. 
**Select â€œSet as default payment methodâ€**

    - 
This option appears only if the card is not already default


  5. 
**Save / Confirm**

    - 
The UI will refresh

    - 
You should now see an indicator showing itâ€™s the **Default**


Thatâ€™s it. No further steps needed.

 


## How to confirm it worked


  - 
The card shows **â€œDefaultâ€** (or similar indicator)

  - 
Subscriptions and profile-based charges stop throwing:



 


## Common gotchas (quick check)


  - 
If you **donâ€™t see â€œSet as defaultâ€**:

    - 
It may already be default

    - 
Or youâ€™re in **sandbox UI lag** â†’ refresh once


  - 
If there are **multiple cards**, only **one** can be default

  - 
Default is **per customer**, not global


 


## When you donâ€™t need default


  - 
**One-time charges using opaqueData** (Accept.js) â†’ default not required

  - 
**Subscriptions / ARB / saved-card retries** â†’ default **required**


 

If you want, I can also:

  - 
Show how to **set default via API** (best for automation)

  - 
Verify your **subscription creation request**

  - 
Help you design a **â€œfirst charge + save card + subscribeâ€** flow

Just tell me what you want next.
***You***: No option to Set as default payment method
***ChatGPT***: This is a **known Authorize.Net UI quirk**, and in your case it actually tells us **exactly what state your account is in**.
Short answer: **the UI is not offering â€œSet as defaultâ€ because the gateway does NOT consider this profile eligible to be defaulted**. Below is how to confirm why, and how to fix it **100% reliably**.

 


## Why the â€œSet as default payment methodâ€ option is missing

In **Authorize.Net**, the UI hides that option when **any one** of these is true:

### 1ï¸âƒ£ There is **no shipping address profile**

This is the **#1 reason** (and very common).

  - 
Subscriptions (ARB) require:

    - 
a **default payment profile**

    - 
and **at least one shipping profile**


  - 
Even if you donâ€™t ship anything, Authorize.Net still expects it.

If **no shipping address exists**, the UI **silently disables default selection**.
âœ… This exactly matches:


Note the wording: **payment / shipping** profile


 


### 2ï¸âƒ£ The profile was auto-created (not fully initialized)

If the payment method was created via:

  - 
an incomplete CIM flow

  - 
partial SDK usage

  - 
or without billing address

Authorize.Net may show the card but not allow defaulting.

 


### 3ï¸âƒ£ UI caching bug (less likely, but real)

Sandbox UI sometimes:

  - 
doesnâ€™t refresh actions

  - 
hides menu items until a profile edit occurs


 


## How to fix this (UI-only, no code)


### âœ… Step 1 â€” Add a Shipping Address (THIS is the key)



  1. 
Open the **Customer Profile**

  2. 
Click **Shipping addresses** tab

  3. 
Click **Add shipping address**

  4. 
Enter **any valid address** (can be same as billing)

  5. 
Save

You do **not** need to use this address anywhere â€” itâ€™s just to satisfy CIM rules.

 


### âœ… Step 2 â€” Refresh & set default


  1. 
Go back to **Payment methods**

  2. 
Click **â‹¯** on the card

  3. 
You should now see:


  4. 
Select it

âœ” UI will now mark it as default

âœ” `E00121` will stop

 


## If the option is STILL missing

Then force a re-initialization:

### Step 3 â€” Edit & save the card (no changes needed)


  1. 
Click **â‹¯ â†’ Edit**

  2. 
Scroll â†’ Save (even without changes)

  3. 
Reload page

This refreshes the internal flags.

 


## Guaranteed fallback (API â€“ always works)

If the UI still blocks you, **the API does not**.
Conceptually:

This **immediately resolves E00121**, regardless of UI state.
(If you want, Iâ€™ll give you the exact Java SDK snippet.)

 


## Why this matters (connecting the dots)

Your situation now is:

  - 
âœ… Customer profile exists

  - 
âœ… Payment profile exists

  - 
âŒ No default payment profile

  - 
âŒ No shipping profile

Authorize.Net therefore:

  - 
lets you **manually charge** the card (UI â€œChargeâ€ works)

  - 
but **rejects subscriptions / ARB / automated flows**

This is expected behavior.

 


## Final checklist (UI path)


  - 
 Add **shipping address**

  - 
 Set **default payment method**

  - 
 Use **customerProfileId + paymentProfileId**

  - 
 Stop sending opaqueData for subscriptions

Once you do this, your subscription flow will succeed.

 

If you want next:

  - 
I can give the **exact API call** to set default (2 minutes)

  - 
Or review your **subscription creation request**

  - 
Or help you design a **clean save-card â†’ subscribe flow**

Just say which one.